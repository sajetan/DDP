#include "common.h"

#include "hw_accelerator.h"
#include <stdint.h>
#include <inttypes.h>

//#include "testvector.h"
//#include "mont.h"


// These variables are defined in the testvector.c
// that is created by the testvector generator python script
extern uint32_t N[32],		// modulus
                e[32],		// encryption exponent
                e_len,		// encryption exponent length
                d[32],		// decryption exponent
                d_len,		// decryption exponent length
                M[32],		// message
                R_1024[32],	// 2^1024 mod N
                R2_1024[32],// (2^1024)^2 mod N
				N_prime[32],
				size ,
				expres[32];

// Uncomment for Session SW2 onwards
//#include "mp_arith.h"
#include "montgomery.h"
//#include "asm_func.h"

void print_num(uint32_t *in, uint32_t size)
{
    int32_t i;

    xil_printf("0x");
    for (i = size-1; i >= 0; i--) {
    	xil_printf("%08x", in[i]);
    }
    xil_printf("\n\r");
}




int main()
{
    init_platform();
    init_performance_counters(1);

    xil_printf("Begin\n\r");


	xil_printf("If the FPGA is not programmed, the program will stuck here!\n\r");


#if 0
	// SW2: multi-precision add/sub
	//----------------------

    //add
    xil_printf("\r\nMP_ADD");
    uint32_t a1[32]   = { 0x5fb6d493, 0xdb0ee8be, 0x704a841e, 0xd09b1f41, 0xcf4f3870, 0xa0d90b3f, 0xdd34e375, 0x02c71f50, 0xbbe0bf21, 0x4cf7dd68, 0xdc580789, 0x9ee98638, 0x708b655f, 0x09c9cf5d, 0x6cbcb152, 0x2988bd7f, 0xa2883faa, 0xbb82748d, 0x9ab7bce3, 0x5dbe293f, 0x52322bd8, 0xaeffcd83, 0xee533ae0, 0x4d4ba990, 0x90ab358f, 0x8e7ff46d, 0xc1b445a6, 0x514f1554, 0x1ae5c5ef, 0xc5dc5c9d, 0x735ad8f6, 0x86580beb };
    uint32_t b1[32]   = { 0x3cf8d180, 0xe7f5a608, 0xc4b6a195, 0xc79d0d06, 0x84b0cdf3, 0x3e5105ed, 0xf06ba2e7, 0x6e29295e, 0x7a6bf7af, 0xfbcb45ef, 0x23192140, 0x173cb903, 0xfb3b0025, 0x419641aa, 0x62c5eae8, 0xa8b835dd, 0xc1b87288, 0x3f262083, 0x27816323, 0x2f7ca6e8, 0x55dc4b30, 0xfff8ded8, 0x1ba1bdf5, 0x5d4bb174, 0x538c03cf, 0x8e853091, 0x48d23333, 0xd3ca9ba6, 0x232b5d61, 0x31758358, 0x118250c0, 0xed8c5aa0 };
	uint32_t res1[33] = { 0x0};

START_TIMING
	mp_add(a1, b1, res1,32);
STOP_TIMING
	xil_printf("\r\nA=");
	print_num(a1, 32);
	xil_printf("B=");
	print_num(b1, 32);
	xil_printf("A+B=");
	print_num(res1, 33);


    //sub
    xil_printf("\r\nMP_SUB");
    uint32_t a2[32]   = { 0xfb7345ad, 0xa972161a, 0x56e7c032, 0xab115e34, 0x54edb161, 0x090b2cd8, 0xb38355cf, 0xfc215f78, 0x02b48c2b, 0x1cf2febf, 0x05f6c7cb, 0xfecea88b, 0x79f6ccea, 0x41258aef, 0x1700ee12, 0x9cf2fab6, 0x81a88642, 0x98df2823, 0xed1154ad, 0xf1bfd75a, 0x51d6de5b, 0xfb808b5f, 0xa622f7c1, 0x5e863645, 0x50142423, 0x9f1313bc, 0xcfef6e97, 0xdd0c07bd, 0x52222e67, 0x02ec3add, 0x06f7ef59, 0x8188c6ab };
    uint32_t b2[32]   = { 0x47f1272b, 0x3f499d07, 0xdc6d6ab3, 0x67ea2462, 0xa8e7a7d8, 0xe4606bb1, 0xcdf2a51f, 0x664b9758, 0x24302a2b, 0xdb256daf, 0xe1e72364, 0x540ba351, 0xad632f6b, 0x715f7e93, 0x91ccd071, 0x11b55bc7, 0xb8444a26, 0xe93a5379, 0x5b96d885, 0xd2d93a5f, 0x2e388bb5, 0x481ae889, 0xa97cc5c6, 0x3c2a5d0a, 0xb6f2b677, 0x02dec0fe, 0xab536a25, 0x5c57a3ed, 0x372426a1, 0x5c718d06, 0x3483f275, 0x802edb99 };
	uint32_t res2[32] = { 0x0};

START_TIMING
	mp_sub(a2, b2, res2,32);
STOP_TIMING
	xil_printf("\r\nA=");
	print_num(a2, 32);
	xil_printf("B=");
	print_num(b2, 32);
	xil_printf("A-B=");
	print_num(res2, 32);

	//mod_add
	xil_printf("\r\nMOD_ADD");


	uint32_t a3[32]   = { 0xa2e47eba, 0xdb5e3e7d, 0x5fd9a7cb, 0x9e7a37c3, 0x4dc37416, 0x834fe315, 0x0080dbac, 0x47280a4d, 0x722dc3dd, 0x7f0ca6f4, 0x7f0da3db, 0xfc20cbb9, 0xb749699e, 0xc5abc925, 0x8bc67669, 0x23a30d3f, 0xffe44e1c, 0xdb22d6ee, 0x5dc3d3b3, 0xfe7e980d, 0x894075d2, 0xdeabe7c4, 0x58042c3b, 0x1cc18107, 0xf0abb2e1, 0x7bd31dc0, 0x72355db9, 0xf55a0178, 0x99f5d831, 0x12ccb47a, 0x44eef089, 0x81bf5831 };
	uint32_t b3[32]   = { 0xe47d092a, 0xd7615ed9, 0xa8aff661, 0xc3d7bb8c, 0x2d22b31c, 0x5050b808, 0xb0bc44bb, 0x93e46f4f, 0xac0332e5, 0x81ad7f85, 0x23de9197, 0x4b35f0a2, 0x6303744a, 0x615740bf, 0x54ebbaef, 0xf36273c2, 0xaf0d1080, 0x4740c9d6, 0x458e6699, 0xaaa1040b, 0x614df162, 0xaf7fe30d, 0xac73e3ed, 0x49204145, 0x1653523c, 0x5ee4f3b1, 0x2b3f4339, 0x5b9a2426, 0x62e3ffb3, 0xf4c32df1, 0x94f2db82, 0x80deb209 };
	uint32_t N3[33]   = { 0xb2e52d11, 0x8f850a5f, 0x08edfb0c, 0x4f02a1ac, 0xdd070636, 0x6c59cfc8, 0x16a40db7, 0x85bba009, 0x598eba07, 0x5d0fa3cc, 0x32bc6fb5, 0x4aa27cd0, 0x0928454e, 0x027d3081, 0xd1caec35, 0xa98e4223, 0x533983de, 0x36370bb4, 0xe8b0b4c6, 0xfe3655ab, 0x27a4a51e, 0xb403c449, 0xa679cf3b, 0xc1fc4391, 0x884e5080, 0xa65d4d30, 0xcd90ed67, 0x55fcb457, 0x989d6f4c, 0x0303d70e, 0x9a09328e, 0x82260dd0, 0x0};
	uint32_t res3[33];
	uint32_t size=32;
START_TIMING
	mod_add(a3,b3,N3, res3, size);
STOP_TIMING
	xil_printf("\r\nA=");
	print_num(a3, 32);
	xil_printf("B=");
	print_num(b3, 32);
	xil_printf("N=");
	print_num(N3, 32);
	xil_printf("(A+B)modN=");
	print_num(res3, 32);


    //mod_sub
    xil_printf("\r\nMOD_SUB");
    uint32_t a4[32]   = { 0x58dbf779, 0x575740d6, 0x22f5f4ff, 0xfee2f9aa, 0xdfd7d85e, 0x6369df65, 0xdf4779e8, 0xefaca94e, 0xa685d499, 0xe4106396, 0x5909a0d5, 0x221befa0, 0x6ebbafcf, 0x31bdd396, 0xda56c836, 0x92800aa3, 0xecda33ae, 0x93e427b6, 0x092c226b, 0x4c7a5e39, 0x4df34625, 0x5fbaa5e8, 0x2a1ae27f, 0xbf51041f, 0x77437504, 0x60e47fed, 0xc677ca07, 0x336b2407, 0x255fdade, 0xdb69e9d1, 0x7588fd3b, 0x83433479 };
    uint32_t b4[32]   = { 0xa77c16c5, 0xfa4935b5, 0xc154ec99, 0x301e2643, 0xb8b8fbdf, 0xc3c8eda2, 0x3d1a8f84, 0x534e3da3, 0x87e0e5da, 0x85c63921, 0x1a47cdf4, 0xc0c2b332, 0xe8ff04bd, 0x0c36bd23, 0xa3c96c3e, 0x308ac41b, 0x2511d7fb, 0x716a9fa9, 0x2418ed5d, 0xcc81526b, 0xc9bbff34, 0x1d8b7599, 0x7eca3082, 0xa026b29d, 0x8377813d, 0x6dba7575, 0x08b7a520, 0xcafc2de6, 0xbf13cec1, 0x4479cc1a, 0xc3ecace7, 0x80b9fa75 };
    uint32_t n4[32]   = { 0xb672e01f, 0x92e9ace2, 0x0ab61389, 0x1302d058, 0x13a6ee9b, 0xfdfb1d3f, 0x2606e136, 0x5317fd7c, 0x4583fe0a, 0xccef8929, 0xf4d2744a, 0x0f13745c, 0xf6641cbe, 0x047608d8, 0xdb7b6221, 0xa2ef20b0, 0x14e04fad, 0x3350974c, 0x0f457ad3, 0xd0ae6914, 0xad9aecc8, 0xe87a5989, 0x92705dc5, 0x8efe769e, 0xfcc342dd, 0x62c646fd, 0x3f7d0ff3, 0xd3af71f1, 0x56483141, 0x0b516398, 0x288a7cfe, 0x83b3d8eb };
    uint32_t res4[32] = { 0x0};

//#if 0
START_TIMING
	mod_sub(a4, b4, n4, res4,32);
STOP_TIMING
	xil_printf("\r\nA=");
	print_num(a4, 32);
	xil_printf("B=");
	print_num(b4, 32);
	xil_printf("N=");
	print_num(n4, 32);
	xil_printf("(A-B)modN=");
	print_num(res4, 32);
#endif

/*--------------------------------------------------------------------------------------------------------
 * Montgomery Multiplication
--------------------------------------------------------------------------------------------------------*/

//    uint32_t a[32]         = { 0xaee66c08, 0x35233dcc, 0x2a299325, 0xd9e3d338, 0x42081c8b, 0xd57a9f22, 0xb62ef3a2, 0x2a166d34, 0x1717b18b, 0xc28518b0, 0xd1213e23, 0xcc1653c1, 0x01fdee5d, 0xcb1ec76c, 0xc64ca144, 0xd0df3f61, 0x9a92d2a5, 0x126a18ef, 0xf3e38e26, 0xa02c0ac2, 0xa3c8db54, 0x99f0c2dd, 0x1b7e7556, 0x21a39126, 0xc9f5b399, 0x90bb5146, 0x08066fca, 0x73174f16, 0xdb009cd3, 0xd473ffc8, 0x16270736, 0x82e9a839 };
//    uint32_t b[32]         = { 0x855eb6f8, 0x6e9b6dff, 0xcd0636cc, 0xbf5773ea, 0xf72af8e6, 0xcbfa44fa, 0x5d58f185, 0xb35d23aa, 0xbfb8a381, 0xa7e23c00, 0x87c6781b, 0x1b1a3c5b, 0xdcc5432f, 0x7360269e, 0x2af92cef, 0xd5b62bf5, 0x9c45cf04, 0x5cfd6b26, 0xf48bb4b4, 0x9b2cb965, 0xa0579f37, 0xaef2010f, 0x955db2d8, 0xf9c705c4, 0x499c3848, 0x05408b7f, 0x0eca67a7, 0x37290375, 0x16fe438f, 0xb0ca5786, 0x26db96be, 0x84726aeb };
//    uint32_t n[32]         = { 0xe8c48a51, 0x1b8dee14, 0x862f952f, 0x8f6b8168, 0x4ea4e323, 0xd35aa574, 0x87f03b6a, 0x3bd7a5a6, 0x8d9479b6, 0xfa121d94, 0x1872cf6f, 0xbd86b870, 0xf4b9ae66, 0x08e92fb5, 0x717bc726, 0x48d634f3, 0x11a967ba, 0x7c79d4b0, 0xc516ec1f, 0x891f3089, 0x15cb661e, 0x1c8b0888, 0x631ec6e3, 0xc02484c2, 0x79b4f388, 0x0d6cba7c, 0x8b63007a, 0x95544192, 0x41425a07, 0x3ae0b97e, 0xc48ce827, 0x9fa0fb98 };
//    uint32_t n_prime[32]   = { 0x771f014f, 0xe7b6501b, 0x208998c4, 0x6494b20d, 0xe5dc4330, 0x5f367118, 0x87262076, 0x6010d23f, 0x7cd53a5f, 0x050059ae, 0x0ff8f7ba, 0x5632ee7a, 0x3061afd6, 0xa2775f9b, 0x84ca257b, 0x540baa52, 0xa789d780, 0x426850b6, 0xa418946c, 0x6dc0e89b, 0x6c2cb558, 0xca8647a6, 0x990312dd, 0x9419d08d, 0x7551f77b, 0xd855314f, 0x33590bdb, 0xe3f2cb2f, 0x20446024, 0xa95f232a, 0xee929e33, 0x17b8e73f };
//    uint32_t eres[32]       = { 0xc34f285c, 0x8dd72476, 0xd6dabaa4, 0x4981dbb8, 0x7692f817, 0x6c97e92a, 0x1d1102c4, 0xf2a4b1ce, 0x9769a3c0, 0xd98bd612, 0x9f4367be, 0x745954be, 0x9953945a, 0x2c32eaeb, 0x80a4d755, 0xb0567f1f, 0x274aa325, 0x4d363ded, 0x4f5e47d4, 0xede7bd3b, 0x69f860a9, 0x115c6838, 0xfbbbf48a, 0x256f0980, 0x7f834df5, 0xe3b1a38b, 0xba6d557a, 0x148e5717, 0x76259941, 0x3acc86da, 0xda543866, 0x9b20a57e };


//seed which uses subtraction
//    uint32_t a[32]         = { 0x57a7083b, 0x69ca4ea0, 0x9fe5b36c, 0x521f2a74, 0x1e6662ef, 0x9d96f043, 0x59cb3b20, 0x8d53e794, 0x6fa7df02, 0x0dc1f9ab, 0x99126998, 0xa3f7bc92, 0x97a9f8f5, 0x5dfac2f6, 0xe15be732, 0xd33f6dfe, 0x0ed446f7, 0x47b0432b, 0xf7629401, 0x2cc36991, 0x3ca36f75, 0xc48a2fc4, 0x74c59a09, 0x75ed233b, 0xed418a8f, 0x3d9b430e, 0xf57ea05b, 0xf7425592, 0xf9aeaa74, 0x42a18953, 0xbea81d7b, 0x8e31fc21 };
//    uint32_t b[32]         = { 0x7054c3b3, 0xfe925599, 0x887f5829, 0xf593dcb1, 0x7570965a, 0xd679ce9d, 0xd67a69d4, 0xad35c581, 0x55652bc3, 0x82b6b9b3, 0xa86cf5b2, 0x1786a1a0, 0xa37262e3, 0xd74512d5, 0x08a3d2ba, 0xbc2e2a56, 0x91116312, 0x3745c777, 0x8e96edbd, 0x6dc56e48, 0x381ca444, 0x51a0f817, 0xfef54747, 0x37e5aafc, 0xf4719e7a, 0x721a8e3d, 0xc3fa6729, 0x21451c50, 0x3fe3e160, 0x86899ae2, 0xc96788d3, 0x9dea4c38 };
//    uint32_t n[32]         = { 0x218be281, 0x18f214a0, 0x1e7e7a6a, 0x894ad60b, 0xb4447a8d, 0x8206815e, 0xdafbdb10, 0xb2388feb, 0x22a50564, 0x264cc822, 0xd40c7a1e, 0x3b7329fa, 0x01989340, 0x2cb0d225, 0x97e46a64, 0x325b3bee, 0xb48ef2c1, 0x86bd6d82, 0x53073169, 0xcc7a5348, 0x40e05200, 0xa4e53820, 0x1571ddf3, 0xe4164b1b, 0xe15f48e6, 0x301ffab5, 0xa5ca284e, 0x32526477, 0x621adf8b, 0x81ce3d70, 0xfc276c58, 0xa0ad3328 };
//    uint32_t n_prime[32]   = { 0x09c5a27f, 0x5100c539, 0x6f99856e, 0x5be195a9, 0xc62b82bf, 0x75339769, 0xc04d5827, 0x448189a7, 0x332070cd, 0x918394a1, 0x33cfd11a, 0xb08921a9, 0x6668d5bc, 0x2b6e8c85, 0x538232ea, 0x3f526487, 0xfce645df, 0x07d32e4f, 0xa3af0e16, 0x1368faa5, 0x2cfa6a65, 0x5ccda53c, 0x6a94db89, 0x3b769407, 0xd32b378f, 0xcc08b782, 0xa91b1e97, 0xf7e95cd5, 0xd91b53b9, 0xc0d68f85, 0x144acbaf, 0xad1597da };
//    uint32_t eres[32]       = { 0xaa85ae35, 0xd4565877, 0x7f9ea6fa, 0x815e4fec, 0x616d063b, 0x09ae3def, 0x0331465d, 0x4b7dfe96, 0x7c08ba58, 0x501ae262, 0x34dbd20b, 0x7d5614fd, 0xf4e30ec2, 0xe8ec160a, 0xaa411edc, 0x7df2673d, 0xd0ba7cf8, 0x19c768b0, 0xbc509983, 0x5ab49338, 0xd06d16f6, 0x712c2d29, 0x7712aa72, 0x809cc149, 0x6f600e8d, 0xbeb9e140, 0x41005116, 0xb355405a, 0x50f4e503, 0x1a984146, 0xc6e77095, 0x6a664b70 };


    uint32_t res[32]={0};
    uint32_t mres[32]={0};
   // uint32_t size = 32;



//	xil_printf("\r\nA=");
//	print_num(a, 32);
//	xil_printf("B=");
//	print_num(b, 32);
//	xil_printf("eres = ");
//	print_num(eres, 32);
//	xil_printf("\n\r");

//	START_TIMING
//	//this uses optimized montgomery multiplication
//	montMulOpt(a, b, n, n_prime, mres, size);
//	STOP_TIMING

//	START_TIMING
//	//this uses non-optimized montgomery multiplication
//	montMul(a, b, n, n_prime, mres, size);
//	STOP_TIMING


//	xil_printf("montgomery multiplication res = ");
//	print_num(mres, 32);
//	xil_printf("\n\r");
//

    START_TIMING
	uint32_t *tres=mont_exp(expres,  M, N, N_prime, R_1024,R2_1024,e,e_len, size);
    STOP_TIMING
	xil_printf("trets =  ");
	print_num(expres, 32);
	xil_printf("\n\r");


//tejas testing

   // uint8x8_t vec =vdup_n_u8(0);
//tejas testing ends


    init_HW_access();
	xil_printf("It did not stuck and HW is initialized!\n\r");


    example_HW_accelerator();


    xil_printf("End\n\r");

    cleanup_platform();

    return 0;
}
